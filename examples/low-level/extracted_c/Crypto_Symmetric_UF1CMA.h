/* This file auto-generated by KreMLin! */
#ifndef __Crypto_Symmetric_UF1CMA_H
#define __Crypto_Symmetric_UF1CMA_H


#include "Prims.h"
#include "FStar_Mul.h"
#include "FStar_Squash.h"
#include "FStar_StrongExcludedMiddle.h"
#include "FStar_List_Tot.h"
#include "FStar_Classical.h"
#include "FStar_ListProperties.h"
#include "FStar_SeqProperties.h"
#include "FStar_Math_Lemmas.h"
#include "FStar_BitVector.h"
#include "FStar_UInt.h"
#include "FStar_Int.h"
#include "FStar_FunctionalExtensionality.h"
#include "FStar_PropositionalExtensionality.h"
#include "FStar_PredicateExtensionality.h"
#include "FStar_TSet.h"
#include "FStar_Set.h"
#include "FStar_Map.h"
#include "FStar_Ghost.h"
#include "FStar_All.h"
#include "FStar_Bytes.h"
#include "FStar_Buffer.h"
#include "Buffer_Utils.h"
#include "Crypto_Symmetric_Bytes.h"
#include "Crypto_Symmetric_Poly1305_Spec.h"
#include "Crypto_Symmetric_Poly1305_Parameters.h"
#include "Crypto_Symmetric_Poly1305_Bigint.h"
#include "Crypto_Symmetric_Poly1305_Bignum_Lemmas_Part1.h"
#include "Crypto_Symmetric_Poly1305_Bignum_Lemmas_Part2.h"
#include "Crypto_Symmetric_Poly1305_Bignum_Lemmas_Part3.h"
#include "Crypto_Symmetric_Poly1305_Bignum_Lemmas_Part4.h"
#include "Crypto_Symmetric_Poly1305_Bignum_Lemmas_Part5.h"
#include "FStar_Buffer_Quantifiers.h"
#include "Crypto_Symmetric_Chacha20.h"
#include "Crypto_Indexing.h"
#include "Flag.h"
#include "Crypto_Symmetric_AES.h"
#include "Crypto_Symmetric_AES128.h"
#include "Crypto_Symmetric_Cipher.h"
#include "Crypto_Symmetric_Poly1305_Lemmas.h"
#include "Crypto_Symmetric_Poly1305_Bignum_Lemmas_Part6.h"
#include "Crypto_Symmetric_Poly1305_Bignum.h"
#include "Crypto_Symmetric_Poly1305.h"
#include "Crypto_Symmetric_GF128_Spec.h"
#include "Crypto_Symmetric_GF128.h"
#include "Crypto_Symmetric_MAC.h"
#include "kremlib.h"
#include "testlib.h"

typedef Crypto_Indexing_macAlg Crypto_Symmetric_UF1CMA_alg;

Crypto_Indexing_macAlg Crypto_Symmetric_UF1CMA_alg_of_id(Crypto_Indexing_id x0);

uint32_t Crypto_Symmetric_UF1CMA_keylen(Crypto_Indexing_id i);

uint32_t Crypto_Symmetric_UF1CMA_skeylen(Crypto_Indexing_id i);

bool Crypto_Symmetric_UF1CMA_skeyed(Crypto_Indexing_id i);

typedef struct {
  enum { Prims_option__uint8_t__None, Prims_option__uint8_t__Some } tag;
  union {
    struct {  } case_None;
    struct { uint8_t *v; } case_Some;
  }
  u;
}
Prims_option__uint8_t_;

uint8_t
*Crypto_Symmetric_UF1CMA_get_skey(
  FStar_HyperHeap_rid rgn,
  Crypto_Indexing_id i,
  Prims_option__uint8_t_ uu____275
);

typedef K___Crypto_Indexing_id_FStar_UInt128_t Crypto_Symmetric_UF1CMA_id;

bool Crypto_Symmetric_UF1CMA_authId(K___Crypto_Indexing_id_FStar_UInt128_t i);

typedef void *Crypto_Symmetric_UF1CMA_text;

typedef struct {
  void *fst;
  void *snd;
}
K___FStar_Seq_seq_FStar_Seq_seq_uint8_t_FStar_Seq_seq_uint8_t;

typedef struct {
  enum {
    Prims_option__K___FStar_Seq_seq_FStar_Seq_seq_uint8_t_FStar_Seq_seq_uint8_t_None,
    Prims_option__K___FStar_Seq_seq_FStar_Seq_seq_uint8_t_FStar_Seq_seq_uint8_t_Some
  }
  tag;
  union {
    struct {  } case_None;
    struct { K___FStar_Seq_seq_FStar_Seq_seq_uint8_t_FStar_Seq_seq_uint8_t v; } case_Some;
  }
  u;
}
Prims_option__K___FStar_Seq_seq_FStar_Seq_seq_uint8_t_FStar_Seq_seq_uint8_t;

typedef Prims_option__K___FStar_Seq_seq_FStar_Seq_seq_uint8_t_FStar_Seq_seq_uint8_t
Crypto_Symmetric_UF1CMA_log;

void
Crypto_Symmetric_UF1CMA_log_cmp_reflexive(
  Prims_option__K___FStar_Seq_seq_FStar_Seq_seq_uint8_t_FStar_Seq_seq_uint8_t a
);

void
Crypto_Symmetric_UF1CMA_log_cmp_transitive(
  Prims_option__K___FStar_Seq_seq_FStar_Seq_seq_uint8_t_FStar_Seq_seq_uint8_t a,
  Prims_option__K___FStar_Seq_seq_FStar_Seq_seq_uint8_t_FStar_Seq_seq_uint8_t b,
  Prims_option__K___FStar_Seq_seq_FStar_Seq_seq_uint8_t_FStar_Seq_seq_uint8_t c
);

void Crypto_Symmetric_UF1CMA_log_cmp_monotonic();

void *Crypto_Symmetric_UF1CMA_ilog(FStar_HyperHeap_rid r, void *l);

typedef struct {
  FStar_HyperHeap_rid x00;
  Crypto_Symmetric_MAC__buffer x01;
  uint8_t *x02;
  void *x03;
}
Crypto_Symmetric_UF1CMA_state____;

FStar_HyperHeap_rid
Crypto_Symmetric_UF1CMA____State___region(
  K___Crypto_Indexing_id_FStar_UInt128_t i,
  Crypto_Symmetric_UF1CMA_state____ projectee
);

Crypto_Symmetric_MAC__buffer
Crypto_Symmetric_UF1CMA____State___r(
  K___Crypto_Indexing_id_FStar_UInt128_t i,
  Crypto_Symmetric_UF1CMA_state____ projectee
);

uint8_t
*Crypto_Symmetric_UF1CMA____State___s(
  K___Crypto_Indexing_id_FStar_UInt128_t i,
  Crypto_Symmetric_UF1CMA_state____ projectee
);

void
Crypto_Symmetric_UF1CMA____State___log(
  K___Crypto_Indexing_id_FStar_UInt128_t i,
  Crypto_Symmetric_UF1CMA_state____ projectee
);

typedef struct {
  uint8_t *fst;
  uint8_t *snd;
}
K___uint8_t__uint8_t_;

typedef void *Crypto_Symmetric_UF1CMA_irtext;

void Crypto_Symmetric_UF1CMA_mk_irtext(void *r);

typedef struct {
  Crypto_Symmetric_MAC__buffer x00;
  void *x01;
}
Crypto_Symmetric_UF1CMA_accBuffer____;

Crypto_Symmetric_MAC__buffer
Crypto_Symmetric_UF1CMA____Acc___a(
  K___Crypto_Indexing_id_FStar_UInt128_t i,
  Crypto_Symmetric_UF1CMA_accBuffer____ projectee
);

void
*Crypto_Symmetric_UF1CMA_alog(
  K___Crypto_Indexing_id_FStar_UInt128_t i,
  Crypto_Symmetric_UF1CMA_accBuffer____ acc
);

void
Crypto_Symmetric_UF1CMA_update(
  K___Crypto_Indexing_id_FStar_UInt128_t i,
  Crypto_Symmetric_UF1CMA_state____ st,
  Crypto_Symmetric_UF1CMA_accBuffer____ acc,
  uint8_t *w
);

void
Crypto_Symmetric_UF1CMA_mac(
  K___Crypto_Indexing_id_FStar_UInt128_t i,
  Crypto_Symmetric_UF1CMA_state____ st,
  Crypto_Symmetric_UF1CMA_accBuffer____ acc,
  uint8_t *tag
);

bool
Crypto_Symmetric_UF1CMA_verify(
  K___Crypto_Indexing_id_FStar_UInt128_t i,
  Crypto_Symmetric_UF1CMA_state____ st,
  Crypto_Symmetric_UF1CMA_accBuffer____ acc,
  uint8_t *received
);
#endif
