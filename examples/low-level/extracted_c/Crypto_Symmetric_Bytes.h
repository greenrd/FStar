/* This file auto-generated by KreMLin! */
#ifndef __Crypto_Symmetric_Bytes_H
#define __Crypto_Symmetric_Bytes_H


#include "Prims.h"
#include "FStar_Mul.h"
#include "FStar_Squash.h"
#include "FStar_StrongExcludedMiddle.h"
#include "FStar_List_Tot.h"
#include "FStar_Classical.h"
#include "FStar_ListProperties.h"
#include "FStar_SeqProperties.h"
#include "FStar_Math_Lemmas.h"
#include "FStar_BitVector.h"
#include "FStar_UInt.h"
#include "FStar_Int.h"
#include "FStar_FunctionalExtensionality.h"
#include "FStar_PropositionalExtensionality.h"
#include "FStar_PredicateExtensionality.h"
#include "FStar_TSet.h"
#include "FStar_Set.h"
#include "FStar_Map.h"
#include "FStar_Ghost.h"
#include "FStar_All.h"
#include "FStar_Bytes.h"
#include "FStar_Buffer.h"
#include "Buffer_Utils.h"
#include "kremlib.h"
#include "testlib.h"

typedef FStar_HyperStack_mem Crypto_Symmetric_Bytes_mem;

typedef uint8_t Crypto_Symmetric_Bytes_u8;

typedef uint32_t Crypto_Symmetric_Bytes_u32;

typedef uint64_t Crypto_Symmetric_Bytes_u64;

typedef void *Crypto_Symmetric_Bytes_bytes;

typedef uint8_t *Crypto_Symmetric_Bytes_buffer;

uint8_t Crypto_Symmetric_Bytes_uint128_to_uint8(FStar_UInt128_t a);

void Crypto_Symmetric_Bytes_print_buffer(uint8_t *s, uint32_t i, uint32_t len);

void *Crypto_Symmetric_Bytes_sel_bytes(FStar_HyperStack_mem h, uint32_t l, uint8_t *buf);

void *Crypto_Symmetric_Bytes_load_bytes(uint32_t l, uint8_t *buf);

void Crypto_Symmetric_Bytes_store_bytes_aux(uint32_t len, uint8_t *buf, uint32_t i, void *b);

void Crypto_Symmetric_Bytes_store_bytes(uint32_t l, uint8_t *buf, void *b);

void Crypto_Symmetric_Bytes_random(Prims_nat len, uint8_t *b);

void *Crypto_Symmetric_Bytes_random_bytes(uint32_t len);

Prims_nat Crypto_Symmetric_Bytes_little_endian(void *b);

Prims_nat Crypto_Symmetric_Bytes_big_endian(void *b);

void Crypto_Symmetric_Bytes_little_endian_null(Prims_nat len);

void Crypto_Symmetric_Bytes_little_endian_singleton(uint8_t n);

void Crypto_Symmetric_Bytes_little_endian_append(void *w1, void *w2);

void Crypto_Symmetric_Bytes_lemma_little_endian_is_bounded(void *b);

void Crypto_Symmetric_Bytes_lemma_big_endian_is_bounded(void *b);

void Crypto_Symmetric_Bytes_lemma_little_endian_lt_2_128(void *b);

uint32_t Crypto_Symmetric_Bytes_load_uint32(uint32_t len, uint8_t *buf);

uint32_t Crypto_Symmetric_Bytes_load_big32(uint32_t len, uint8_t *buf);

uint64_t Crypto_Symmetric_Bytes_load_big64(uint32_t len, uint8_t *buf);

FStar_UInt128_t Crypto_Symmetric_Bytes_uint8_to_uint128(uint8_t a);

FStar_UInt128_t Crypto_Symmetric_Bytes_load_uint128(uint32_t len, uint8_t *buf);

void Crypto_Symmetric_Bytes_store_uint32(uint32_t len, uint8_t *buf, uint32_t n);

void Crypto_Symmetric_Bytes_store_big32(uint32_t len, uint8_t *buf, uint32_t n);

void *Crypto_Symmetric_Bytes_uint32_bytes(uint32_t len, uint32_t n);

void *Crypto_Symmetric_Bytes_uint32_be(uint32_t len, uint32_t n);

void *Crypto_Symmetric_Bytes_little_bytes(uint32_t len, Prims_nat n);

void Crypto_Symmetric_Bytes_store_uint128(uint32_t len, uint8_t *buf, FStar_UInt128_t n);

typedef void *Crypto_Symmetric_Bytes_word;

void Crypto_Symmetric_Bytes_lemma_little_endian_is_injective_0(void *b);

void
Crypto_Symmetric_Bytes_lemma_little_endian_is_injective_1(
  Prims_pos b,
  Prims_nat q,
  Prims_nat r,
  Prims_nat q_,
  Prims_nat r_
);

void Crypto_Symmetric_Bytes_lemma_little_endian_is_injective_2(void *b, Prims_pos len);

void
Crypto_Symmetric_Bytes_lemma_little_endian_is_injective_3(void *b, void *b_, Prims_pos len);

void Crypto_Symmetric_Bytes_lemma_little_endian_is_injective(void *b, void *b_, Prims_nat len);
#endif
